CHAPTER 5
Hands On
=====================================================================
1.
SQL> SELECT min(customer#) min, max(customer#) as max from customers;

       MIN	  MAX
---------- ----------
      1001	 1020

SQL> CREATE SEQUENCE customer_id_seq START WITH 1021
  2  INCREMENT BY 1;

Sequence created.

2.
SQL> INSERT INTO customers(customer#, lastname, firstname,zip)                            
  2  VALUES(cust_id_seq.NEXTVAL,'Shoulders','Frank',23567);

1 row created.

3.
SQL> CREATE SEQUENCE my_first_seq START WITH 5 INCREMENT BY -3 MAXVALUE 5 MINVALUE 0 NOCYCLE;

Sequence created.

4.
SQL> SELECT my_first_seq.NEXTVAL FROM dual;

   NEXTVAL
----------
	 5

SQL> SELECT my_first_seq.NEXTVAL FROM dual;

   NEXTVAL
----------
	 2

SQL> SELECT my_first_seq.NEXTVAL FROM dual;
SELECT my_first_seq.NEXTVAL FROM dual
*
ERROR at line 1:
ORA-08004: sequence MY_FIRST_SEQ.NEXTVAL goes below MINVALUE and cannot be
instantiated

5.
SQL> ALTER SEQUENCE my_first_seq MINVALUE -1000;

Sequence altered.

6.
SQL> CREATE TABLE email_log(
  2      emailid NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
  3  ,   emaildate DATE 
  4  ,   customer# NUMBER 
  5  );

Table created.

SQL> INSERT INTO email_log(emaildate, customer#)
  2  VALUES(sysdate,1007);

1 row created.

SQL> INSERT INTO email_log(emailid,emaildate,customer#)
  2  VALUES(default,sysdate,1008);

1 row created.

SQL> INSERT INTO email_log(emailid,emaildate,customer#)
  2  VALUES(25,sysdate,1009);   

7.
SQL> CREATE OR REPLACE SYNONYM numgen FOR my_first_seq;

Synonym created.

8.
SQL> SELECT numgen.currval from dual;
SELECT numgen.currval from dual
       *
ERROR at line 1:
ORA-08002: sequence NUMGEN.CURRVAL is not yet defined in this session


SQL> select numgen.NEXTVAL FROM dual;

   NEXTVAL
----------
	-1

SQL> SELECT numgen.currval from dual;

   CURRVAL
----------
	-1

9.
SQL> CREATE BITMAP INDEX state_indx ON customers(state);

Index created.

SQL> SELECT INDEX_NAME, TABLE_NAME FROM USER_INDEXES WHERE table_name = 'CUSTOMERS';

INDEX_NAME		               TABLE_NAME
------------------------------ ------------------------------
CUSTOMERS_CUSTOMER#_PK	       CUSTOMERS
STATE_INDX		               CUSTOMERS

SQL> DROP INDEX state_indx;

Index dropped.

10.
SQL> CREATE BITMAP INDEX lastname_indx ON customers(lastname);

Index created.

SQL> SELECT index_name, table_name FROM user_indexes 
  2  WHERE table_name = 'CUSTOMERS';

INDEX_NAME		       TABLE_NAME
------------------------------ ------------------------------
CUSTOMERS_CUSTOMER#_PK	       CUSTOMERS
LASTNAME_INDX		       CUSTOMERS

SQL> DROP INDEX lastname_indx;

Index dropped.

11.
SQL> CREATE INDEX dates_indx ON orders(orderdate,shipdate);

Index created.









===========================================================================
CHAPTER 5
ADVANCED CHALLENGE
===========================================================================

I've looked up the keys that are normally used and select statements and they do not have apppropriate sequences and indexes except on primary keys. To speed up the selections we have to create three indexes and three sequences as follows : 

    Indexes: 
           Rationale: To speedup searching of books based on the following columns:
             1. name of the publisher in the publisher table - we will sometimes need to lookup all books published by a particular publisher. 
             2. name of book_store - to lookup store based on store_name
             3. title of the books table - to lookup books based on title
    Sequences: to generate auto-numbers for populating  
             1. Storeid of the book_store table to generate the store_ids
             2. pubid of the publisher table
             3. authorid of the publisher table